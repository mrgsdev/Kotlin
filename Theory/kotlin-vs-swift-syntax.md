# Сравнение синтаксиса Kotlin и Swift

Kotlin и Swift — это современные языки программирования, созданные как улучшенные альтернативы для своих платформ: Kotlin для JVM (в основном Android), Swift для iOS/macOS. Хотя они имеют схожую философию и цели, их синтаксис и особенности имеют как сходства, так и различия.

## Основы синтаксиса

### Объявление переменных

**Kotlin:**
```kotlin
val константа = 42 // неизменяемая (immutable)
var переменная = "Привет" // изменяемая (mutable)

// Явное указание типа:
val число: Int = 42
var текст: String = "Привет"
```

**Swift:**
```swift
let константа = 42 // неизменяемая (immutable)
var переменная = "Привет" // изменяемая (mutable)

// Явное указание типа:
let число: Int = 42
var текст: String = "Привет"
```

Здесь мы видим первое большое сходство: оба языка используют похожие ключевые слова `let/val` для констант и `var` для переменных. Также оба языка поддерживают вывод типов и явное их указание.

### Функции

**Kotlin:**
```kotlin
fun приветствие(имя: String): String {
    return "Привет, $имя!"
}

// Функция с выражением:
fun приветствие(имя: String) = "Привет, $имя!"

// Параметры по умолчанию:
fun приветствие(имя: String = "гость") = "Привет, $имя!"
```

**Swift:**
```swift
func приветствие(имя: String) -> String {
    return "Привет, \(имя)!"
}

// Параметры по умолчанию:
func приветствие(имя: String = "гость") -> String {
    return "Привет, \(имя)!"
}
```

Отличия:
1. Kotlin использует ключевое слово `fun`, Swift — `func`
2. В Kotlin возвращаемый тип указывается после двоеточия, в Swift — после стрелки `->` 
3. Kotlin поддерживает однострочные функции с `=`, Swift требует возврат значения через `return`
4. Интерполяция строк: `$переменная` в Kotlin, `\(переменная)` в Swift

### Классы и объекты

**Kotlin:**
```kotlin
class Пользователь(val имя: String, var возраст: Int) {
    fun представиться() {
        println("Меня зовут $имя, мне $возраст лет")
    }
}

// Использование:
val пользователь = Пользователь("Иван", 30)
println(пользователь.имя) // доступ к свойству
пользователь.представиться() // вызов метода
```

**Swift:**
```swift
class Пользователь {
    let имя: String
    var возраст: Int
    
    init(имя: String, возраст: Int) {
        self.имя = имя
        self.возраст = возраст
    }
    
    func представиться() {
        print("Меня зовут \(имя), мне \(возраст) лет")
    }
}

// Использование:
let пользователь = Пользователь(имя: "Иван", возраст: 30)
print(пользователь.имя) // доступ к свойству
пользователь.представиться() // вызов метода
```

Главное отличие: Kotlin поддерживает конструкторы как часть объявления класса, а Swift требует отдельного метода `init`. В Swift параметры вызова конструктора именованные, в Kotlin — позиционные (хотя именованные тоже поддерживаются).

## Ключевые отличия

### 1. Null-безопасность

**Kotlin:**
```kotlin
var имя: String = "Иван" // не может быть null
var имяНулевое: String? = null // может быть null

// Безопасный вызов:
имяНулевое?.length // вернет null, если имяНулевое == null

// Оператор !!:
имяНулевое!!.length // выбросит NullPointerException, если имяНулевое == null

// Элвис-оператор:
val длина = имяНулевое?.length ?: 0 // длина = 0, если имяНулевое == null
```

**Swift:**
```swift
var имя: String = "Иван" // не может быть nil
var имяНулевое: String? = nil // может быть nil

// Безопасный вызов:
имяНулевое?.count // вернет nil, если имяНулевое == nil

// Force unwrapping (принудительная распаковка):
имяНулевое!.count // выбросит ошибку, если имяНулевое == nil

// Оператор объединения с nil (nil coalescing):
let длина = имяНулевое?.count ?? 0 // длина = 0, если имяНулевое == nil
```

Сходство: оба языка имеют похожие механизмы работы с null/nil значениями.
Различия: `!!` в Kotlin vs `!` в Swift, `?:` в Kotlin vs `??` в Swift.

### 2. Расширения (Extensions)

**Kotlin:**
```kotlin
fun String.добавитьВосклицание(): String {
    return this + "!"
}

// Использование:
val восклицание = "Привет".добавитьВосклицание() // "Привет!"
```

**Swift:**
```swift
extension String {
    func добавитьВосклицание() -> String {
        return self + "!"
    }
}

// Использование:
let восклицание = "Привет".добавитьВосклицание() // "Привет!"
```

Отличие: Swift использует блок `extension`, в Kotlin расширения объявляются напрямую.

### 3. Свойства и методы доступа

**Kotlin:**
```kotlin
class Прямоугольник {
    var ширина = 0
    var высота = 0
    
    val площадь: Int
        get() = ширина * высота
}
```

**Swift:**
```swift
class Прямоугольник {
    var ширина = 0
    var высота = 0
    
    var площадь: Int {
        return ширина * высота
    }
}
```

### 4. Управление потоком

**Условные выражения:**

**Kotlin:**
```kotlin
val результат = if (x > 0) "положительное" else "отрицательное"

when (x) {
    0 -> println("Ноль")
    1, 2 -> println("Один или два")
    in 10..20 -> println("От 10 до 20")
    is String -> println("Это строка")
    else -> println("Что-то другое")
}
```

**Swift:**
```swift
let результат = x > 0 ? "положительное" : "отрицательное"

switch x {
case 0:
    print("Ноль")
case 1, 2:
    print("Один или два")
case 10...20:
    print("От 10 до 20")
case is String:
    print("Это строка")
default:
    print("Что-то другое")
}
```

Ключевое отличие: Kotlin использует выражение `when`, которое похоже на `switch` в Swift, но более гибкое.

### 5. Циклы

**Kotlin:**
```kotlin
for (i in 1..10) {
    println(i)
}

for (элемент in массив) {
    println(элемент)
}

// Цикл с индексом:
for ((индекс, значение) in массив.withIndex()) {
    println("$индекс: $значение")
}
```

**Swift:**
```swift
for i in 1...10 {
    print(i)
}

for элемент in массив {
    print(элемент)
}

// Цикл с индексом:
for (индекс, значение) in массив.enumerated() {
    print("\(индекс): \(значение)")
}
```

Разница незначительная: `..` vs `...` для диапазона, `withIndex()` vs `enumerated()` для индексации.

### 6. Интерфейсы и протоколы

**Kotlin:**
```kotlin
interface Летающий {
    fun лететь()
    
    // Метод с реализацией по умолчанию:
    fun приземлиться() {
        println("Приземление")
    }
}

class Птица : Летающий {
    override fun лететь() {
        println("Птица летит")
    }
}
```

**Swift:**
```swift
protocol Летающий {
    func лететь()
    
    // Метод с реализацией по умолчанию требует extension:
}

// Расширение с реализацией по умолчанию:
extension Летающий {
    func приземлиться() {
        print("Приземление")
    }
}

class Птица: Летающий {
    func лететь() {
        print("Птица летит")
    }
}
```

Отличие: в Swift реализация по умолчанию для протоколов должна быть в отдельном extension, в Kotlin можно прямо в интерфейсе.

### 7. Делегирование

**Kotlin:**
```kotlin
interface База {
    fun вывести()
}

class БазоваяРеализация : База {
    override fun вывести() { println("Базовый вывод") }
}

// Делегирование:
class Делегат(b: База) : База by b {
    // Автоматически получает все методы из b
}
```

**Swift:**
```swift
protocol База {
    func вывести()
}

class БазоваяРеализация: База {
    func вывести() { print("Базовый вывод") }
}

// Swift не имеет встроенного синтаксиса делегирования:
class Делегат: База {
    private let база: База
    
    init(база: База) {
        self.база = база
    }
    
    func вывести() {
        база.вывести()
    }
}
```

Ключевое отличие: Kotlin имеет встроенное делегирование с ключевым словом `by`, Swift требует ручной реализации.

## Другие важные отличия

1. **Модификаторы доступа**:
   - Kotlin: `public` (по умолчанию), `private`, `protected`, `internal`
   - Swift: `open`, `public`, `internal` (по умолчанию), `fileprivate`, `private`

2. **Обработка исключений**:
   - Kotlin использует механизм try-catch с проверяемыми исключениями
   - Swift использует do-try-catch с типом `Error`

3. **Функциональное программирование**:
   - Kotlin: лямбды, высокоуровневые функции, встроенная поддержка
   - Swift: замыкания (closures), функции высшего порядка

4. **Дополнительно в Kotlin**:
   - Data-классы (`data class`)
   - Companion-объекты (вместо статических методов)
   - Coroutines для асинхронного программирования

5. **Дополнительно в Swift**:
   - Структуры как первоклассные типы (`struct`)
   - Опционалы (`Optional<T>`) как отдельный тип
   - Swift Package Manager для управления зависимостями

Оба языка современные и выразительные, с акцентом на безопасность и лаконичность. Хотя синтаксис во многом похож, каждый язык имеет свои уникальные особенности, соответствующие экосистеме, для которой он был создан.
